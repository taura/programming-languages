<!--- md --->

#* How compilers translate your program

<!--- end md --->

<!--- md w --->

Enter your name and student ID.

 * Name:
 * Student ID:

<!--- end md --->

<!--- md --->

<a name="intro"> </a>
# Introduction

* You look at assembly code generated by the compiler to get a good sense of how source programs are compiled into machine (assembly) code

<!--- end md --->

<!--- md --->

# Let the compiler generate assembly code

* when you compile a program or build a project, a compiler generally compiles it all the way into an executable
* that is, machine (or assembly) code is generated during the process, but is discarded after the compilation
* you first have to know how to let your compiler emit and leave assembly code 
* how to do that exactly is language- or compiler-dependent

<!--- end md --->

<!--- md --->
## Go

### A simple example

* when executed by SHIFT + ENTER, the following cell simply writes the content (excluding the first `%%writefile go/add123.go`) into the specified file `go/add123.go`
* note that it is a feature of Python kernel and you don't have to (and should not) change it to `Go` kernel
<!--- end md --->

<!--- code kernel=py --->
%%writefile go/add123.go

<!--- exec-include ./mk_version.py -D label="add123" nb/source/pl06_how_it_gets_compiled/include/pl06.go --->
<!--- end code --->

<!--- md --->
### How to emit assembly code

* ordinary go compiler does not support emitting native 64 bit x86 assembly
* it instead emits something called "plan 9 assembly" ([details](https://go.dev/doc/asm)), which is a machine-independent, therefore portable, assembly
* portability is good, but for the learning objective of this exercise, it obscures how your program executes on the real machine
* therefore, in this exercise, we instead use an alternative compiler, `gccgo`, which generates a native assembly for x86
  * `-S` to emit assembly code
  * `-O` to optimize
  * `-g0` not to generate debugging information (unncessary for now)
<!--- end md --->

<!--- code w kernel=bash --->
gccgo -O -g0 -S go/add123.go -o go/add123.s
cat go/add123.s
<!--- end code --->

<!--- md --->

* find the label starting the function `Add123`, which may not be exactly `Add123`

* **NOTE 1:**
  * you need to say `package xxx`, with _xxx_ anything other than `main`; if you say `package main`, the compiler complains about the lack of `main` function
  * you need to <font color="red">capitalize the function name</font> whose assembly code you want to see, as otherwise the compiler may eliminate it as a dead code
  * in Go, functions starting with an uppercase letter are visible (can be called) from another package (see https://go.dev/doc/tutorial/create-module), so the compiler should leave the assembly code even if it finds the function not called anywhere in the file it is compiling

* **NOTE 2:** if you want to use `gccgo` along with `go build`, you can do
```
go build -compiler gccgo 
```
instead of just 
```
go build
```
<!--- end md --->


<!--- md --->
## Julia

### A simple example

* when executed by SHIFT + ENTER, the following cell simply writes the content (excluding the first `%%writefile jl/add123.jl`) into the specified file `jl/add123.jl`
* note that it is a feature of Python kernel and you don't have to (and should not) change it to `Julia` kernel

<!--- end md --->

<!--- code kernel=py --->
%%writefile jl/add123.jl

<!--- exec-include ./mk_version.py -D label="add123" nb/source/pl06_how_it_gets_compiled/include/pl06.jl --->
<!--- end code --->

<!--- md --->

### How to emit assembly code

* Julia has <font color="blue">code_native</font> function that prints assembly code of a function given particular concrete types for its input parameters
* running this program defines `add123` and then calls `code_native` function, which shows assembly code for a specified function
<!--- end md --->

<!--- code kernel=bash --->
julia jl/add123.jl
<!--- end code --->

<!--- md --->
* you can alternatively write only the definition of a function in the `.jl` file and call `code_native` in the command line
<!--- end md --->

<!--- code kernel=py --->
%%writefile jl/add123.jl

<!--- exec-include ./mk_version.py -D label="add123x" nb/source/pl06_how_it_gets_compiled/include/pl06.jl --->
<!--- end code --->

<!--- code kernel=bash --->
julia --load jl/add123.jl --eval 'using InteractiveUtils; code_native(add123)'
<!--- end code --->

<!--- md --->
* find the label starting the function `add123`, which may not be exactly `add123`
<!--- end md --->

<!--- md --->
* note that the function `add123` declares the type of the input parameter (`n`) as `Int64`; you could give a different type or omit its type altogether and see how the generated coce change
* you can alternatively specify input type as the second parameter of `code_native`, like `code_native(add123, (Int64,))` or `code_native(add123, (Float64,))` in which case you perhaps want to omit the type in the definition
<!--- end md --->


<!--- md --->

## OCaml

### A simple example

* when executed by SHIFT + ENTER, the following cell simply writes the content (excluding the first `%%writefile ml/add123.ml`) into the specified file `ml/add123.ml`
* note that it is a feature of Python kernel and you don't have to (and should not) change it to `OCaml` kernel
<!--- end md --->

<!--- code kernel=py --->
%%writefile ml/add123.ml

<!--- exec-include ./mk_version.py -D label="add123" nb/source/pl06_how_it_gets_compiled/include/pl06.ml --->
<!--- end code --->

<!--- md --->

### How to emit assembly code

* `ocamlopt` is a "native compiler" that translates OCaml source into machine code (`ocamlc` compiles OCaml to bytecode)
  * `-S` to emit assembly code

<!--- end md --->

<!--- code w kernel=bash --->
ocamlopt -S ml/add123.ml
cat ml/add123.s
<!--- end code --->
<!--- md --->
* find the label starting the function `add123`, which may not be exactly `add123`
<!--- end md --->

<!--- md --->
## Rust

### A simple example

* when executed by SHIFT + ENTER, the following cell simply writes the content (excluding the first `%%writefile rs/add123.rs`) into the specified file `rs/add123.rs`
* note that it is a feature of Python kernel and you don't have to (and should not) change it to `Rust` kernel

<!--- end md --->

<!--- code kernel=py --->
%%writefile rs/add123.rs

<!--- exec-include ./mk_version.py -D label="add123" nb/source/pl06_how_it_gets_compiled/include/pl06.rs --->
<!--- end code --->

<!--- md --->

### How to emit assembly code

* `rustc` is a compiler for Rust, which is internally called by `cargo`
  * `-O` to optimize
  * `--emit asm` to generate assembly code
  * `--crate-type lib` to say this is for a library, not an executable
<!--- end md --->

<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/add123.rs -o rs/add123.s
cat rs/add123.s
<!--- end code --->

<!--- md --->
* try to find out where the function starts and instructions actually performing the addition

* **NOTE:**
  * `--crate-type lib` says you are building a library which will be called from another program, not an executable; without it, the compiler complains about the lack of `main` function
  * `#[no_mangle]` guarantees the label name corresponding to `add123` is exactly `add123` and has a side-effect of preventing the compiler from eliminating the function as dead code (I try to find a way to guarantee `add123` is not eliminatd without `#[no_mangle]`, but couldn't.  let me know if you know a better way)
<!--- end md --->

<!--- md --->

#*P Calling convention (where are args and return values?)

* define a function `many_args` (or `Many_args` in Go) that takes many (> 10) integer parameters and returns the sum of them (similar to the following C function) in your language, compile it into assembly and examine it
<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/many_args.c

<!--- exec-include ./mk_version.py -D label="many_args" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O3 -S cc/many_args.c -o cc/many_args.s
cat cc/many_args.s
<!--- end code --->

<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/many_args.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/many_args.go -o go/many_args.s
cat go/many_args.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/many_args.jl --eval 'using InteractiveUtils; code_native(many_args)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/many_args.ml
cat ml/many_args.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/many_args.rs -o rs/many_args.s
cat rs/many_args.s
<!--- end code --->

<!--- md --->
* __<font color="blue">Questions:</font>__
  1. how are parameters passed in each language? (which registers? memory?); are they different across the languages?
  1. how does your language represent an integer $x$? does it use _natural_ machine representation? are they different across the languages?

<!--- end md --->

<!--- md --->

#*P How floating point numbers are represented

* define a function `add_floats` (or `Add_floats` in Go) that takes two floating point numbers and returns the sum of the two (similar to the following C function) in your language, compile it into assembly and examine it
<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/add_floats.c

<!--- exec-include ./mk_version.py -D label="add_floats" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O3 -S cc/add_floats.c -o cc/add_floats.s
cat cc/add_floats.s
<!--- end code --->

<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/add_floats.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/add_floats.go -o go/add_floats.s
cat go/add_floats.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/add_floats.jl --eval 'using InteractiveUtils; code_native(add_floats)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/add_floats.ml
cat ml/add_floats.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/add_floats.rs -o rs/add_floats.s
cat rs/add_floats.s
<!--- end code --->

<!--- md --->
* __<font color="blue">Questions:</font>__
  1. how are the two parameters passed in each language? (which registers? memory?); are they different across the languages?
  1. how does your language represent a floating point number $x$? are they different across the languages?
  1. is there any language whose floating point number computations will be significantly slower?

<!--- end md --->

<!--- md --->

#*P How arrays are represented

* define a function `get_float_array_elem` (or `get_float_array_elem` in Go) that takes an array of floating point numbers, `a`, and an integer, `i`, and returns `i`-th element of `a` (similar to to the following C function) in your language, compile it into assembly and examine it
* for an array, use
  * `[]float64` (slice) for Go
  * `Vector{Float64}` for Julia
  * `float array` (slice) for OCaml
  * `Vec<f64>` for Rust
<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/get_float_array_elem.c

<!--- exec-include ./mk_version.py -D label="get_float_array_elem" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O3 -S cc/get_float_array_elem.c -o cc/get_float_array_elem.s
cat cc/get_float_array_elem.s
<!--- end code --->

<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/get_float_array_elem.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/get_float_array_elem.go -o go/get_float_array_elem.s
cat go/get_float_array_elem.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/get_float_array_elem.jl --eval 'using InteractiveUtils; code_native(get_float_array_elem)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/get_float_array_elem.ml
cat ml/get_float_array_elem.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/get_float_array_elem.rs -o rs/get_float_array_elem.s
cat rs/get_float_array_elem.s
<!--- end code --->

<!--- md --->
* __<font color="blue">Questions:</font>__
  1. how does each language represent the respective array-like data structure?
  1. how does each language detect out-of-bound array access? 

<!--- end md --->

<!--- md --->

#*P How structs are represented

* define a struct `point` (or `Point` in Go) that has two fields (`x` and `y`; both are 64 bit floating point numbers) and function `get_struct_elem` (or `Get_struct_elem` in Go) that takes a point or a pointer to it and returns its `y` field
<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/get_struct_elem.c

<!--- exec-include ./mk_version.py -D label="get_struct_elem" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O3 -S cc/get_struct_elem.c -o cc/get_struct_elem.s
cat cc/get_struct_elem.s
<!--- end code --->

<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/get_struct_elem.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/get_struct_elem.go -o go/get_struct_elem.s
cat go/get_struct_elem.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/get_struct_elem.jl --eval 'using InteractiveUtils; code_native(get_struct_elem)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/get_struct_elem.ml
cat ml/get_struct_elem.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/get_struct_elem.rs -o rs/get_struct_elem.s
cat rs/get_struct_elem.s
<!--- end code --->

<!--- md --->
* __<font color="blue">Questions:</font>__
  1. how does each language represent multiword structures?
  1. does each language possibly get a null pointer?
  1. if so, how it prepare for it?

<!--- end md --->

<!--- md --->

#*P If statement/expressions

* define a function `collatz` (or `Collatz` in Go) that takes an integer $n$ and returns $n/2$ if $n$ is an even number and $3 n + 1$ otherwise (similar to the following C function)
<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/collatz.c

<!--- exec-include ./mk_version.py -D label="collatz" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O3 -S cc/collatz.c -o cc/collatz.s
cat cc/collatz.s
<!--- end code --->

<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/collatz.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/collatz.go -o go/collatz.s
cat go/collatz.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/collatz.jl --eval 'using InteractiveUtils; code_native(collatz)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/collatz.ml
cat ml/collatz.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/collatz.rs -o rs/collatz.s
cat rs/collatz.s
<!--- end code --->

<!--- md --->
* __<font color="blue">Questions:</font>__
  1. how if statement/expression is implemented?

<!--- end md --->


<!--- md --->

#*P Function call

* define a function `regions` (or `Regions` in Go) that takes an integer $n$ and returns $r_n$ of the following recurrence

$$ \begin{array}{rcl} r_0 & = & 1, \\ r_n & = & r_{n-1} + n \quad (n > 0) \end{array} $$

* write it in the straightforward recursion as you have done in the functional programming exercise (similar to the following C function)
<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/regions.c

<!--- exec-include ./mk_version.py -D label="regions" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O -S cc/regions.c -o cc/regions.s
cat cc/regions.s
<!--- end code --->

<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/regions.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/regions.go -o go/regions.s
cat go/regions.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/regions.jl --eval 'using InteractiveUtils; code_native(regions)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/regions.ml
cat ml/regions.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/regions.rs -o rs/regions.s
cat rs/regions.s
<!--- end code --->

<!--- md --->
* __<font color="blue">Questions:</font>__
  1. to compute `regions(n - 1) + n - 1`, the value of `n` (or `n - 1`) must be saved somewhere before calling `regions(n - 1)`, so that `X + n - 1` can be computed after `regions(n - 1)` returns `X`.  how it is accomplished?

<!--- end md --->



<!--- md --->

#*P Tail recursive call

* in it, define a function `regions_tail` (or `regions_tail` in Go) that does the same thing as `regions` in a slightly different way
* without details, you can understand the following C function computes the above $a_n$ if called with `regions_tail(0, n, 1)`
* do the same for your language

<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/regions_tail.c

<!--- exec-include ./mk_version.py -D label="regions_tail" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O2 -S cc/regions_tail.c -o cc/regions_tail.s
cat cc/regions_tail.s
<!--- end code --->


<!--- md --->

* generally, a function call whose return value becomes the return value of the caller is called a _tail call_
* for example, the function call `g(x)` below is a tail call, but `h(x)` is not
```
def f(x):
   if ...:
      return g(x)
   else:
      return h(x) + 1
```
* a _tail call_ that is also a recursive call is called a _tail recursive call_ and a compiler generally has a chance to optimize tail recursive calls
* a loop can generally be expressed as tail recursive functions
```
while A:
  B
```
can be translated into something like
```
def loop(...):
  if A:
     B
     loop(...)
```
* in particular, in OCaml, where loop syntax exist but more functional way of writing things is encouraged, writing what would a loop in other languages in tail recursive functions is a trick you want to master

<!--- end md --->



<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/regions_tail.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/regions_tail.go -o go/regions_tail.s
cat go/regions_tail.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/regions_tail.jl --eval 'using InteractiveUtils; code_native(regions_tail)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/regions_tail.ml
cat ml/regions_tail.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/regions_tail.rs -o rs/regions_tail.s
cat rs/regions_tail.s
<!--- end code --->

<!--- md --->
* __<font color="blue">Questions:</font>__
  1. does your language successfully eliminate stack space for each function call?

<!--- end md --->



<!--- md --->

#*P How arrays are scanned

* in it, define a function `sum_vector_floats` (or `Sum_vector_floats` in Go) that takes an array of floating point numbers and returns the sum of all its elements (similar to to the following C function) in your language, compile it into assembly and examine it
* use
  * `[]float64` (slice) for Go
  * `Vector{Float64}` for Julia
  * `float array` (slice) for OCaml
  * `Vec<f64>` for Rust
* write them in
  * ordinary loop syntax (except OCaml)
  * tail-recursive functions
<!--- end md --->

<!--- code kernel=py --->
%%writefile cc/sum_vector_floats.c

<!--- exec-include ./mk_version.py -D label="sum_array_floats" nb/source/pl06_how_it_gets_compiled/include/pl06.cc --->
<!--- end code --->

<!--- code w kernel=bash --->
gcc -O3 -S cc/sum_vector_floats.c -o cc/sum_vector_floats.s
cat cc/sum_vector_floats.s
<!--- end code --->



<!--- md --->
* write the code below
* <font color="red">replace xx with go, jl, ml, or rs and write the function</font>
<!--- end md --->

<!--- code kernel=py --->
%%writefile xx/sum_vector_floats.xx

<!--- end code --->

<!--- md --->
* and see the assembly code by executing one of the following
<!--- end md --->

<!--- md --->
Go
<!--- end md --->
<!--- code w kernel=bash --->
gccgo -O -g0 -S go/sum_vector_floats.go -o go/sum_vector_floats.s
cat go/sum_vector_floats.go
<!--- end code --->

<!--- md --->
Julia
<!--- end md --->
<!--- code w kernel=bash --->
julia --load jl/sum_vector_floats.jl --eval 'using InteractiveUtils; code_native(sum_vector_floats)'
<!--- end code --->

<!--- md --->
OCaml
<!--- end md --->
<!--- code w kernel=bash --->
ocamlopt -S ml/sum_vector_floats.ml
cat ml/sum_vector_floats.ml
<!--- end code --->

<!--- md --->
Rust
<!--- end md --->
<!--- code w kernel=bash --->
rustc -O --emit asm --crate-type lib rs/sum_vector_floats.rs -o rs/sum_vector_floats.s
cat rs/sum_vector_floats.s
<!--- end code --->


<!--- md --->
* __<font color="blue">Questions:</font>__
  * given that the array has a large number of elements, identify the loop that takes most of the time
  * in that loop, how many instructions are executed per array element?
  * will there be a performance difference between the loop version and tail recursive call version?
  * what does each language/compiler do to optimize it?

<!--- end md --->

